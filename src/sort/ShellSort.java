package sort;

// +----------------------------------------------------------------------
// | ProjectName: algorithm_study_record
// +----------------------------------------------------------------------
// | Date: 2019/3/5
// +----------------------------------------------------------------------
// | Time: 16:36
// +----------------------------------------------------------------------
// +----------------------------------------------------------------------
public class ShellSort extends AbstractSort {

    /**
     * 希尔排序
     * 原理就是将大数组分割成小数组,开始的分割跨度比较大,一般是分割后的小数组只有两个元素,然后进行插入排序,
     * 渐渐的缩小跨度,分割后的数组的元素渐渐增多,但是由于之前已经执行过排序,此时分割后的数组的有序度较高,使得插入排序性能较高,
     * 等跨度缩小到1时,此时执行的的是对整个数组进行的插入排序,但是当前的数组的有序度超级高  性能也超级高
     *
     * 极适合乱序大数组排序场景
     *
     * @param comparables
     */
    @Override
    public void sort(Comparable[] comparables) {

        int len = comparables.length;
        int h = 1;

        //指定首次跨度大小
        while (h < len/3) h = h * 3 + 1;


        while (h >= 1){
            for (int i = h; i < len; i++) {
                for (int j = i; j >= h && comparables[j].compareTo(comparables[j - h]) < 0; j -= h) {
                    exchange(comparables,j,j-h);
                }
            }
            h /= 3;
        }
    }
}
